/* 
    exploitdb.cpp
    DetExploit program file related to ExploitDB.
    DetExploit (https://github.com/moppoi5168/DetExploit)
    Licensed by GPL License
*/

#include "detexploit.hpp"

std::map<std::string, std::string> proc_edb(HANDLE hStdout) {
    std::vector<std::string> extracted;
    std::map<std::string, std::string> edb_vulndata;
    edb_download_vulndata(hStdout);
    extracted = edb_extract_vulndata(hStdout);
    edb_vulndata = edb_parse_vulndata(extracted);
    return edb_vulndata;
}

int edb_download_vulndata(HANDLE hStdout) {
    LPCTSTR Url, File;
    HRESULT hr;
    std::cout << EXPLOITDB_DOWNLOAD_INTRO << std::endl;
    std::string edb_url = "";
    std::string savepath = EDB_VULNDATA_FILENAME;
    Url = _T("https://github.com/offensive-security/exploitdb/raw/master/files_exploits.csv");
    File = _T(EDB_VULNDATA_FILENAME);
    hr = URLDownloadToFile(0, Url, File, 0, 0);
    if (checkFileExistence(EDB_VULNDATA_FILENAME)) {
        SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN);
        std::cout << EXPLOITDB_DOWNLOAD_SUCCESS << std::endl;
        SetConsoleTextAttribute(hStdout, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        std::cout << "===========================================================" << std::endl;
    } else {
        SetConsoleTextAttribute(hStdout, FOREGROUND_RED);
        std::cout << EXPLOITDB_DOWNLOAD_FAILED << std::endl;
        SetConsoleTextAttribute(hStdout, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        exit(1);
    }
}

std::vector<std::string> edb_extract_vulndata(HANDLE hStdout) {
    std::vector<std::string> tmp;
    std::string str;
    std::ifstream ifs(EDB_VULNDATA_FILENAME);
    std::string extract_msg = EXPLOITDB_EXTRACT_WIN;
    extract_msg += EDB_VULNDATA_FILENAME;
    extract_msg += "......";
    std::cout << extract_msg << std::endl;
    while (getline(ifs, str)) {
        if (str.find("windows") != std::string::npos) {
            tmp.push_back(str.c_str());
        }
    }
    SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN);
    std::cout << EXPLOITDB_EXTRACT_SUCCESS << std::endl;
    SetConsoleTextAttribute(hStdout, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
    std::cout << "===========================================================" << std::endl;
    return tmp;
}

std::map<std::string, std::string> edb_parse_vulndata(std::vector<std::string> data_list) {
    std::map<std::string, std::string> product_dict;
    for (int i = 0; i < data_list.size(); i++) {
        std::vector<std::string> splitted = split(data_list[i], ",");
        std::string base = splitted[2];
        std::vector<std::string> splitted_sec = split(base, " ");
        std::string name = splitted_sec[0] + splitted_sec[1];
        std::string version = splitted_sec[2];
        product_dict[name] = version;
    }
    return product_dict;
}

std::map<std::string, VulnInfo> edb_scan(std::map<std::string, std::string> edb_vulndata, std::map<std::string, std::string> installed) {
    std::map<std::string, VulnInfo> resultdict;
    std::string level = "";
    VulnInfo vinfo;
    for (auto fit = edb_vulndata.begin(); fit != edb_vulndata.end(); fit++) {
        for (auto nit = installed.begin(); nit != installed.end(); nit++) {
            if ((*fit).first == (*nit).first && (*fit).second == (*nit).second) {
                level = determine_severity(EDB, "NOEXT");
                vinfo.version = (*fit).second;
                vinfo.is_edb = true;
                vinfo.is_jvn = false;
                vinfo.is_nvd = false;
                vinfo.is_winupd = false;
                vinfo.severity = level;
                resultdict[(*fit).first] = vinfo;
                std::cout << "===========================================================" << std::endl;
                std::cout << DETECT_ALERT << std::endl;
                std::cout << APP_NAME << (*fit).first << " >>" << std::endl;
                std::cout << APP_VERSION << (*fit).second << " >>" << std::endl;
                std::cout << DETECT_USING_NVD << std::endl;
                std::cout << OBJECT_LEVEL << level << " >>" << std::endl;
                std::cout << "===========================================================" << std::endl;
            }
        }
    }
    return resultdict;
}
